/**
 * CLAUDYNE DATABASE SYNCHRONIZATION ENGINE
 * Synchronisation bidirectionnelle JSON ‚Üî PostgreSQL
 * Automatisation compl√®te avec monitoring
 * En hommage √† Meffo Mehtah Tchandjio Claudine
 */

const { Pool } = require('pg');
const fs = require('fs');
const path = require('path');

class ClaudyneDatabaseSync {
    constructor() {
        this.usersFile = path.join(__dirname, 'users.json');
        this.logFile = path.join(__dirname, 'logs', 'sync.log');

        // Configuration PostgreSQL
        this.pgConfig = {
            host: process.env.DB_HOST || 'localhost',
            port: process.env.DB_PORT || 5432,
            database: process.env.DB_NAME || 'claudyne_production',
            user: process.env.DB_USER || 'claudyne_user',
            password: process.env.DB_PASSWORD || 'aujourdhui18D@',
            ssl: false,
            max: 20,
            idleTimeoutMillis: 30000,
            connectionTimeoutMillis: 5000,
        };

        this.pool = null;
        this.isPostgresAvailable = false;

        this.initializeSync();
    }

    // ========================================
    // INITIALISATION
    // ========================================

    async initializeSync() {
        this.log('üöÄ Initialisation Claudyne Database Sync Engine');

        // Cr√©er r√©pertoire logs
        const logsDir = path.dirname(this.logFile);
        if (!fs.existsSync(logsDir)) {
            fs.mkdirSync(logsDir, { recursive: true });
        }

        // Tester connexion PostgreSQL
        await this.testPostgreSQLConnection();

        // Premi√®re synchronisation
        if (this.isPostgresAvailable) {
            await this.syncJSONToPostgreSQL();
        }
    }

    async testPostgreSQLConnection() {
        try {
            this.pool = new Pool(this.pgConfig);

            const client = await this.pool.connect();
            await client.query('SELECT NOW()');
            client.release();

            this.isPostgresAvailable = true;
            this.log('‚úÖ PostgreSQL connexion √©tablie');

            // Cr√©er table users si inexistante
            await this.ensureUsersTable();

        } catch (error) {
            this.isPostgresAvailable = false;
            this.log(`‚ùå PostgreSQL indisponible: ${error.message}`);
            this.log('üîÑ Mode JSON pur activ√©');
        }
    }

    async ensureUsersTable() {
        const createTableQuery = `
            CREATE TABLE IF NOT EXISTS users (
                id BIGSERIAL PRIMARY KEY,
                email VARCHAR(255) UNIQUE,
                password VARCHAR(255) NOT NULL,
                "firstName" VARCHAR(255) NOT NULL,
                "lastName" VARCHAR(255) NOT NULL,
                phone VARCHAR(50),
                role VARCHAR(50) DEFAULT 'PARENT',
                "userType" VARCHAR(50) DEFAULT 'MANAGER',
                "isActive" BOOLEAN DEFAULT true,
                "isVerified" BOOLEAN DEFAULT false,
                "createdAt" TIMESTAMP DEFAULT NOW(),
                "updatedAt" TIMESTAMP DEFAULT NOW(),
                "lastLogin" TIMESTAMP
            );
        `;

        try {
            await this.pool.query(createTableQuery);
            this.log('‚úÖ Table users cr√©√©e/v√©rifi√©e');
        } catch (error) {
            this.log(`‚ùå Erreur cr√©ation table: ${error.message}`);
        }
    }

    // ========================================
    // SYNCHRONISATION JSON ‚Üí POSTGRESQL
    // ========================================

    async syncJSONToPostgreSQL() {
        if (!this.isPostgresAvailable) {
            this.log('‚ö†Ô∏è PostgreSQL indisponible - Sync annul√©e');
            return false;
        }

        try {
            const jsonUsers = this.loadJSONUsers();
            let syncCount = 0;

            this.log(`üîÑ Sync JSON ‚Üí PostgreSQL (${jsonUsers.length} utilisateurs)`);

            for (const user of jsonUsers) {
                const synced = await this.syncUserToPostgreSQL(user);
                if (synced) syncCount++;
            }

            this.log(`‚úÖ Sync termin√©e: ${syncCount}/${jsonUsers.length} utilisateurs`);
            return true;

        } catch (error) {
            this.log(`‚ùå Erreur sync JSON ‚Üí PostgreSQL: ${error.message}`);
            return false;
        }
    }

    async syncUserToPostgreSQL(jsonUser) {
        const upsertQuery = `
            INSERT INTO users (
                id, email, password, "firstName", "lastName", phone,
                role, "userType", "isActive", "isVerified", "createdAt", "lastLogin"
            ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
            ON CONFLICT (email) DO UPDATE SET
                password = EXCLUDED.password,
                "firstName" = EXCLUDED."firstName",
                "lastName" = EXCLUDED."lastName",
                phone = EXCLUDED.phone,
                role = EXCLUDED.role,
                "userType" = EXCLUDED."userType",
                "isActive" = EXCLUDED."isActive",
                "isVerified" = EXCLUDED."isVerified",
                "lastLogin" = EXCLUDED."lastLogin",
                "updatedAt" = NOW()
            RETURNING id;
        `;

        try {
            const values = [
                jsonUser.id,
                jsonUser.email,
                jsonUser.password,
                jsonUser.firstName,
                jsonUser.lastName,
                jsonUser.phone,
                jsonUser.role || 'PARENT',
                jsonUser.userType || 'MANAGER',
                jsonUser.isActive !== false,
                jsonUser.isVerified || false,
                jsonUser.createdAt ? new Date(jsonUser.createdAt) : new Date(),
                jsonUser.lastLogin ? new Date(jsonUser.lastLogin) : null
            ];

            const result = await this.pool.query(upsertQuery, values);
            return result.rows[0]?.id;

        } catch (error) {
            this.log(`‚ùå Erreur sync utilisateur ${jsonUser.email}: ${error.message}`);
            return false;
        }
    }

    // ========================================
    // SYNCHRONISATION POSTGRESQL ‚Üí JSON
    // ========================================

    async syncPostgreSQLToJSON() {
        if (!this.isPostgresAvailable) {
            this.log('‚ö†Ô∏è PostgreSQL indisponible - Sync annul√©e');
            return false;
        }

        try {
            const pgUsers = await this.loadPostgreSQLUsers();

            this.log(`üîÑ Sync PostgreSQL ‚Üí JSON (${pgUsers.length} utilisateurs)`);

            // Convertir au format JSON
            const jsonUsers = pgUsers.map(user => ({
                id: parseInt(user.id),
                email: user.email,
                password: user.password,
                firstName: user.firstName,
                lastName: user.lastName,
                phone: user.phone,
                role: user.role,
                userType: user.userType,
                isActive: user.isActive,
                isVerified: user.isVerified,
                createdAt: user.createdAt.toISOString(),
                lastLogin: user.lastLogin ? user.lastLogin.toISOString() : null
            }));

            this.saveJSONUsers(jsonUsers);
            this.log(`‚úÖ Sync PostgreSQL ‚Üí JSON termin√©e: ${jsonUsers.length} utilisateurs`);

            return true;

        } catch (error) {
            this.log(`‚ùå Erreur sync PostgreSQL ‚Üí JSON: ${error.message}`);
            return false;
        }
    }

    async loadPostgreSQLUsers() {
        const query = `
            SELECT id, email, password, "firstName", "lastName", phone,
                   role, "userType", "isActive", "isVerified", "createdAt", "lastLogin"
            FROM users
            WHERE "isActive" = true
            ORDER BY "createdAt" DESC
        `;

        const result = await this.pool.query(query);
        return result.rows;
    }

    // ========================================
    // SYNCHRONISATION BIDIRECTIONNELLE
    // ========================================

    async performFullSync() {
        this.log('üîÑ === SYNCHRONISATION BIDIRECTIONNELLE COMPL√àTE ===');

        if (!this.isPostgresAvailable) {
            await this.testPostgreSQLConnection();
        }

        if (this.isPostgresAvailable) {
            // 1. JSON ‚Üí PostgreSQL
            await this.syncJSONToPostgreSQL();

            // 2. PostgreSQL ‚Üí JSON (pour r√©cup√©rer IDs et timestamps)
            await this.syncPostgreSQLToJSON();
        } else {
            this.log('‚ö†Ô∏è Mode JSON pur - Pas de synchronisation PostgreSQL');
        }

        this.log('‚úÖ === SYNCHRONISATION TERMIN√âE ===');
    }

    // ========================================
    // UTILITAIRES JSON
    // ========================================

    loadJSONUsers() {
        try {
            if (fs.existsSync(this.usersFile)) {
                const data = fs.readFileSync(this.usersFile, 'utf8');
                return JSON.parse(data);
            }
        } catch (error) {
            this.log(`‚ùå Erreur lecture JSON: ${error.message}`);
        }
        return [];
    }

    saveJSONUsers(users) {
        try {
            fs.writeFileSync(this.usersFile, JSON.stringify(users, null, 2));
            this.log(`‚úÖ JSON sauvegard√©: ${users.length} utilisateurs`);
        } catch (error) {
            this.log(`‚ùå Erreur sauvegarde JSON: ${error.message}`);
        }
    }

    // ========================================
    // MONITORING ET LOGS
    // ========================================

    log(message) {
        const timestamp = new Date().toISOString();
        const logEntry = `[${timestamp}] ${message}`;

        console.log(logEntry);

        try {
            fs.appendFileSync(this.logFile, logEntry + '\n');
        } catch (error) {
            console.error('Erreur √©criture log:', error.message);
        }
    }

    // ========================================
    // SURVEILLANCE AUTOMATIQUE
    // ========================================

    startAutoSync(intervalMinutes = 5) {
        this.log(`üîÑ Synchronisation automatique activ√©e (${intervalMinutes} min)`);

        setInterval(async () => {
            await this.performFullSync();
        }, intervalMinutes * 60 * 1000);
    }

    // ========================================
    // API PUBLIQUE
    // ========================================

    async getStatus() {
        const jsonUsers = this.loadJSONUsers();
        let pgUsers = 0;

        if (this.isPostgresAvailable) {
            try {
                const result = await this.pool.query('SELECT COUNT(*) FROM users WHERE "isActive" = true');
                pgUsers = parseInt(result.rows[0].count);
            } catch (error) {
                this.log(`‚ùå Erreur count PostgreSQL: ${error.message}`);
            }
        }

        return {
            postgresAvailable: this.isPostgresAvailable,
            jsonUsers: jsonUsers.length,
            postgresUsers: pgUsers,
            lastSync: new Date().toISOString(),
            database: this.pgConfig.database
        };
    }
}

// ========================================
// EXPORT ET UTILISATION
// ========================================

module.exports = ClaudyneDatabaseSync;

// Utilisation directe si script ex√©cut√©
if (require.main === module) {
    require('dotenv').config();

    const sync = new ClaudyneDatabaseSync();

    // Arguments en ligne de commande
    const args = process.argv.slice(2);

    if (args.includes('--full-sync')) {
        setTimeout(() => sync.performFullSync(), 1000);
    } else if (args.includes('--auto-sync')) {
        setTimeout(() => sync.startAutoSync(2), 1000); // Toutes les 2 minutes
    } else if (args.includes('--status')) {
        setTimeout(async () => {
            const status = await sync.getStatus();
            console.log('üìä STATUS CLAUDYNE DATABASE:');
            console.log(JSON.stringify(status, null, 2));
        }, 1000);
    } else {
        console.log(`
üéì CLAUDYNE DATABASE SYNC ENGINE
En hommage √† Meffo Mehtah Tchandjio Claudine

Usage:
  node sync-database.js --full-sync     # Synchronisation compl√®te
  node sync-database.js --auto-sync     # Synchronisation automatique
  node sync-database.js --status        # Statut des bases
        `);
    }
}