/**
 * Service Worker pour Claudyne
 * Optimisation pour connexions 2G/3G et mode offline
 * Sp√©cialement adapt√© pour le march√© camerounais
 */

const CACHE_NAME = 'claudyne-v1.2.2';
const OFFLINE_URL = '/offline.html';

// Ressources critiques √† mettre en cache
const CRITICAL_RESOURCES = [
    '/',
    '/index.html',
    '/admin-interface.html',
    '/admin-secure-k7m9x4n2p8w5z1c6',
    '/student-interface-modern.html'
];

// Ressources secondaires (charg√©es en mode progressive)
const SECONDARY_RESOURCES = [
    '/parent-interface/index.html',
    '/moderator-interface.html'
];

// Installation du Service Worker
self.addEventListener('install', event => {
    console.log('üîß Installation du Service Worker Claudyne');

    event.waitUntil(
        Promise.all([
            // Cache des ressources critiques avec gestion d'erreur
            cacheResourcesSafely(CRITICAL_RESOURCES),
            // Prise de contr√¥le imm√©diate
            self.skipWaiting()
        ])
    );
});

// Cache les ressources de mani√®re s√©curis√©e (ne plante pas si une ressource n'existe pas)
async function cacheResourcesSafely(resources) {
    const cache = await caches.open(CACHE_NAME);
    console.log('üì¶ Mise en cache s√©curis√©e des ressources critiques');

    const cachePromises = resources.map(async (url) => {
        try {
            const request = new Request(url, {cache: 'reload'});
            const response = await fetch(request);

            if (response.ok) {
                await cache.put(request, response);
                console.log('‚úÖ Ressource cach√©e:', url);
            } else {
                console.warn('‚ö†Ô∏è Ressource non trouv√©e (ignor√©e):', url, response.status);
            }
        } catch (error) {
            console.warn('‚ö†Ô∏è Impossible de cacher (ignor√©):', url, error.message);
        }
    });

    await Promise.allSettled(cachePromises);
    console.log('üì¶ Cache initial termin√©');
}

// Activation du Service Worker
self.addEventListener('activate', event => {
    console.log('‚úÖ Activation du Service Worker Claudyne');
    
    event.waitUntil(
        Promise.all([
            // Nettoyage des anciens caches
            caches.keys().then(cacheNames => {
                return Promise.all(
                    cacheNames
                        .filter(cacheName => cacheName !== CACHE_NAME)
                        .map(cacheName => {
                            console.log('üóëÔ∏è Suppression cache obsol√®te:', cacheName);
                            return caches.delete(cacheName);
                        })
                );
            }),
            // Prise de contr√¥le de toutes les pages
            self.clients.claim()
        ])
    );
});

// Strat√©gies de cache intelligentes selon le type de connexion
self.addEventListener('fetch', event => {
    const request = event.request;
    const url = new URL(request.url);

    // Ignore les requ√™tes non-HTTP
    if (!request.url.startsWith('http')) {
        return;
    }

    // Strat√©gie diff√©rente selon le type de ressource
    if (url.pathname.endsWith('.html') || url.pathname === '/admin-secure-k7m9x4n2p8w5z1c6') {
        event.respondWith(handlePageRequest(request));
    } else if (url.pathname.includes('/api/')) {
        event.respondWith(handleAPIRequest(request));
    } else if (isStaticResource(url.pathname)) {
        event.respondWith(handleStaticResource(request));
    } else {
        event.respondWith(handleOtherRequests(request));
    }
});

// Gestion des pages HTML - Cache First avec fallback
async function handlePageRequest(request) {
    try {
        const url = new URL(request.url);

        // Si c'est le chemin admin s√©curis√©, servir admin-interface.html
        if (url.pathname === '/admin-secure-k7m9x4n2p8w5z1c6') {
            console.log('üîê Requ√™te admin s√©curis√©e d√©tect√©e');
            const adminRequest = new Request('/admin-interface.html', {
                method: request.method,
                headers: request.headers
            });

            // Essayer depuis le cache d'abord
            const cachedResponse = await caches.match(adminRequest);
            if (cachedResponse) {
                console.log('üìñ Admin interface servie depuis le cache');
                return cachedResponse;
            }

            // Sinon r√©cup√©rer depuis le r√©seau
            if (navigator.onLine) {
                try {
                    const networkResponse = await fetch(adminRequest);
                    if (networkResponse.ok) {
                        const cache = await caches.open(CACHE_NAME);
                        cache.put(adminRequest, networkResponse.clone());
                        console.log('üåê Admin interface r√©cup√©r√©e et mise en cache');
                        return networkResponse;
                    }
                } catch (error) {
                    console.warn('‚ö†Ô∏è Impossible de r√©cup√©rer admin-interface.html depuis le r√©seau');
                }
            }
        }

        // Tentative de r√©cup√©ration depuis le cache
        const cachedResponse = await caches.match(request);

        if (cachedResponse) {
            console.log('üìñ Page servie depuis le cache:', request.url);

            // Mise √† jour en arri√®re-plan si en ligne
            if (navigator.onLine) {
                fetch(request).then(response => {
                    if (response.ok) {
                        caches.open(CACHE_NAME).then(cache => {
                            cache.put(request, response.clone());
                        });
                    }
                }).catch(() => {
                    // Ignore les erreurs de mise √† jour en arri√®re-plan
                });
            }

            return cachedResponse;
        }

        // Si pas en cache et en ligne, r√©cup√©rer et cacher
        if (navigator.onLine) {
            const networkResponse = await fetch(request);

            if (networkResponse.ok) {
                const cache = await caches.open(CACHE_NAME);
                cache.put(request, networkResponse.clone());
                console.log('üåê Page r√©cup√©r√©e et mise en cache:', request.url);
                return networkResponse;
            }
        }

        // Fallback vers la page offline
        console.log('üì¥ Redirection vers page offline');
        return caches.match(OFFLINE_URL);

    } catch (error) {
        console.error('‚ùå Erreur lors du chargement de page:', error);
        return caches.match(OFFLINE_URL);
    }
}

// Gestion des appels API - Network First avec timeout court
async function handleAPIRequest(request) {
    try {
        // Timeout court pour les API (3 secondes)
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 3000);

        const networkResponse = await fetch(request, {
            signal: controller.signal
        });
        
        clearTimeout(timeoutId);

        if (networkResponse.ok) {
            // Cache les r√©ponses API GET non sensibles
            if (request.method === 'GET' && !request.url.includes('auth')) {
                const cache = await caches.open(CACHE_NAME);
                cache.put(request, networkResponse.clone());
            }
            return networkResponse;
        }

        // Fallback vers cache pour les GET
        if (request.method === 'GET') {
            const cachedResponse = await caches.match(request);
            if (cachedResponse) {
                console.log('üì° API r√©ponse depuis cache:', request.url);
                return cachedResponse;
            }
        }

        return new Response(
            JSON.stringify({ 
                error: 'Service temporarily unavailable',
                message: 'Connexion lente d√©tect√©e, veuillez r√©essayer'
            }), 
            { 
                status: 503,
                headers: { 'Content-Type': 'application/json' }
            }
        );

    } catch (error) {
        console.log('üì° API request failed, trying cache:', request.url);
        
        // Tentative de r√©cup√©ration depuis le cache
        if (request.method === 'GET') {
            const cachedResponse = await caches.match(request);
            if (cachedResponse) {
                return cachedResponse;
            }
        }

        return new Response(
            JSON.stringify({ 
                error: 'Network error',
                message: 'Veuillez v√©rifier votre connexion internet'
            }), 
            { 
                status: 503,
                headers: { 'Content-Type': 'application/json' }
            }
        );
    }
}

// Gestion des ressources statiques - Cache First
async function handleStaticResource(request) {
    try {
        const cachedResponse = await caches.match(request);
        
        if (cachedResponse) {
            return cachedResponse;
        }

        const networkResponse = await fetch(request);
        
        if (networkResponse.ok) {
            const cache = await caches.open(CACHE_NAME);
            cache.put(request, networkResponse.clone());
        }

        return networkResponse;

    } catch (error) {
        console.error('‚ùå Erreur ressource statique:', error);
        
        // Retour d'une r√©ponse minimale pour CSS/JS manquant
        if (request.url.endsWith('.css')) {
            return new Response('/* Ressource CSS non disponible */', {
                headers: { 'Content-Type': 'text/css' }
            });
        }
        
        if (request.url.endsWith('.js')) {
            return new Response('// Ressource JS non disponible', {
                headers: { 'Content-Type': 'application/javascript' }
            });
        }

        throw error;
    }
}

// Gestion des autres requ√™tes
async function handleOtherRequests(request) {
    try {
        // Timeout normal pour les autres ressources (10 secondes)
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 10000);

        const response = await fetch(request, {
            signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        return response;

    } catch (error) {
        console.log('üåê Autres requ√™tes √©chou√©es:', request.url);
        
        // Tentative cache en dernier recours
        const cachedResponse = await caches.match(request);
        if (cachedResponse) {
            return cachedResponse;
        }

        throw error;
    }
}

// Utilitaire pour identifier les ressources statiques
function isStaticResource(pathname) {
    const staticExtensions = ['.css', '.js', '.png', '.jpg', '.jpeg', '.gif', '.svg', '.ico', '.woff', '.woff2'];
    return staticExtensions.some(ext => pathname.endsWith(ext));
}

// Messages vers l'application principale
self.addEventListener('message', event => {
    const { type, data } = event.data;

    switch (type) {
        case 'CACHE_SECONDARY':
            // Cache les ressources secondaires en arri√®re-plan
            cacheSecondaryResources();
            break;
            
        case 'CLEAR_CACHE':
            // Nettoyage du cache sur demande
            clearAllCaches();
            break;
            
        case 'GET_CACHE_SIZE':
            // Retourne la taille du cache
            getCacheSize().then(size => {
                event.ports[0].postMessage({ size });
            });
            break;
    }
});

// Cache progressif des ressources secondaires
async function cacheSecondaryResources() {
    console.log('üì¶ Cache progressif des ressources secondaires');

    const cache = await caches.open(CACHE_NAME);

    for (const url of SECONDARY_RESOURCES) {
        try {
            const request = new Request(url);
            const response = await fetch(request);

            if (response.ok) {
                await cache.put(request, response);
                console.log('‚úÖ Ressource secondaire cach√©e:', url);
            } else {
                console.warn('‚ö†Ô∏è Ressource secondaire non trouv√©e (ignor√©e):', url, response.status);
            }
        } catch (error) {
            console.warn('‚ö†Ô∏è Impossible de cacher ressource secondaire:', url, error.message);
        }
    }
}

// Nettoyage complet du cache
async function clearAllCaches() {
    const cacheNames = await caches.keys();
    
    await Promise.all(
        cacheNames.map(cacheName => {
            console.log('üóëÔ∏è Suppression cache:', cacheName);
            return caches.delete(cacheName);
        })
    );
    
    console.log('üßπ Tous les caches ont √©t√© supprim√©s');
}

// Calcul de la taille du cache
async function getCacheSize() {
    const cache = await caches.open(CACHE_NAME);
    const requests = await cache.keys();
    
    let totalSize = 0;
    
    for (const request of requests) {
        try {
            const response = await cache.match(request);
            if (response) {
                const blob = await response.blob();
                totalSize += blob.size;
            }
        } catch (error) {
            console.warn('‚ö†Ô∏è Erreur calcul taille:', error);
        }
    }
    
    return {
        bytes: totalSize,
        mb: (totalSize / 1024 / 1024).toFixed(2),
        items: requests.length
    };
}

// Gestion des erreurs globales
self.addEventListener('error', event => {
    console.error('‚ùå Erreur Service Worker:', event.error);
});

self.addEventListener('unhandledrejection', event => {
    console.error('‚ùå Promise rejet√©e dans Service Worker:', event.reason);
});

console.log('üöÄ Service Worker Claudyne initialis√© - Version', CACHE_NAME);